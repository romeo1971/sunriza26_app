rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {
    // Helper Functions (Struppi-System)
    function signedIn() { return request.auth != null; }
    function isOwner(data) { return signedIn() && data.userId == request.auth.uid; }
    // Nur epoch millis zulässig (ursprüngliches Verhalten)
    function validTimestamp(ts) { return ts is int && ts > 0; }
    function validString(s, min, max) { return s is string && s.size() >= min && s.size() <= max; }
    function isAdmin() {
      return signedIn() &&
        exists(/databases/$(db)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(db)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }
    // Avatar-Besitz prüfen: entweder Root-Avatar-Dokument gehört dem Nutzer
    // ODER es existiert ein Nutzer-gebundenes Avatar-Dokument unter users/{uid}/avatars/{avatarId}
    function ownsAvatar(avatarId) {
      return (
        // Root-Dokument vorhanden und gehört Nutzer
        exists(/databases/$(db)/documents/avatars/$(avatarId)) &&
        isOwner(get(/databases/$(db)/documents/avatars/$(avatarId)).data)
      ) || (
        // Oder es existiert ein Mapping unter dem Nutzerpfad
        signedIn() && exists(/databases/$(db)/documents/users/$(request.auth.uid)/avatars/$(avatarId))
      );
    }
    // (entfernt: ungenutzte Helper)

    // Media-Pricing validieren
    function validMediaPricing(data) {
      return data.isFree == true
        || (!('isFree' in data) || data.isFree == null)
        || (data.isFree == false 
            && (!('price' in data) || data.price == null || (data.price is number && data.price >= 0))
            && (!('currency' in data) || data.currency == null || data.currency in ['EUR', 'USD', '€', '$', '£', '¥', 'CHF'])
            && (!('platformFeePercent' in data) || data.platformFeePercent == null 
                || (data.platformFeePercent is number && data.platformFeePercent >= 0 && data.platformFeePercent <= 100)));
    }

    // User-Dokumente (Struppi-System)
    match /users/{uid} {
      allow get, create, delete: if signedIn() && uid == request.auth.uid;
      
      // Update: Erlaubt auch arrayUnion/arrayRemove für favoriteAvatarIds
      // ABER: Credits-Felder dürfen sich NICHT ÄNDERN (müssen gleich bleiben)
      allow update: if signedIn() && uid == request.auth.uid
        && (
          !('credits' in request.resource.data) 
          || request.resource.data.credits == resource.data.get('credits', 0)
        )
        && (
          !('creditsPurchased' in request.resource.data) 
          || request.resource.data.creditsPurchased == resource.data.get('creditsPurchased', 0)
        )
        && (
          !('creditsSpent' in request.resource.data) 
          || request.resource.data.creditsSpent == resource.data.get('creditsSpent', 0)
        );
      
      // Transactions (Käufer-Transaktionen)
      match /transactions/{transactionId} {
        allow read: if signedIn() && uid == request.auth.uid;
        allow create: if signedIn(); // Cloud Function kann schreiben
      }
      
      // Sales (Verkäufer-Verkäufe)
      match /sales/{saleId} {
        allow read: if signedIn() && uid == request.auth.uid;
        allow create: if signedIn(); // Cloud Function kann schreiben
      }
      
      // Moments (Gekaufte/Angenommene Media Files)
      match /moments/{momentId} {
        allow read: if signedIn() && uid == request.auth.uid;
        allow create: if signedIn() && uid == request.auth.uid
          && request.resource.data.keys().hasOnly(['id', 'userId', 'avatarId', 'type', 'mediaId', 'originalUrl', 'storedUrl', 'thumbUrl', 'originalFileName', 'acquiredAt', 'price', 'currency', 'paymentMethod', 'tags', 'downloadCount', 'maxDownloads'])
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.type in ['image', 'video', 'audio', 'document']
          && request.resource.data.originalUrl is string
          && request.resource.data.storedUrl is string
          && request.resource.data.acquiredAt is int
          && (!('paymentMethod' in request.resource.data) || request.resource.data.paymentMethod in ['free', 'credits', 'stripe'])
          && (!('tags' in request.resource.data) || request.resource.data.tags is list)
          && (!('downloadCount' in request.resource.data) || (request.resource.data.downloadCount is int && request.resource.data.downloadCount >= 0))
          && (!('maxDownloads' in request.resource.data) || (request.resource.data.maxDownloads is int && request.resource.data.maxDownloads >= 1 && request.resource.data.maxDownloads <= 10));
        allow delete: if signedIn() && uid == request.auth.uid;
        allow update: if signedIn() && uid == request.auth.uid;
      }
      
      // Receipts (Kauf-/Download-Belege)
      match /receipts/{receiptId} {
        allow read: if signedIn() && uid == request.auth.uid;
        allow create: if signedIn() // Cloud Function kann schreiben
          && request.resource.data.keys().hasOnly(['id', 'userId', 'avatarId', 'momentId', 'price', 'currency', 'paymentMethod', 'createdAt', 'stripePaymentIntentId', 'metadata'])
          && request.resource.data.userId == uid
          && request.resource.data.paymentMethod in ['free', 'credits', 'stripe']
          && request.resource.data.price is number
          && request.resource.data.createdAt is int;
      }
      
      // Purchased Media (Tracking welche Media Items gekauft wurden)
      match /purchased_media/{mediaId} {
        allow read: if signedIn() && uid == request.auth.uid;
        allow create: if signedIn() // Cloud Function oder Frontend kann schreiben
          && request.resource.data.keys().hasOnly(['mediaId', 'avatarId', 'type', 'price', 'currency', 'credits', 'purchasedAt'])
          && request.resource.data.purchasedAt is int;
      }
    }

    // Avatar-Dokumente (Struppi-System)
    match /avatars/{avatarId} {
      // Create mit minimalen Pflichtfeldern + optionalen Medienfeldern
      allow create: if signedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasOnly([
          'id','userId','firstName','nickname','lastName',
          'birthDate','deathDate','calculatedAge','avatarImageUrl',
          'imageUrls','videoUrls','textFileUrls','audioUrls','writtenTexts',
          'lastMessage','lastMessageTime','createdAt','updatedAt','isPublic',
          'training','role','greetingText','city','postalCode','country',
          'liveAvatar','imageTimeline','videoAudioEnabled'
        ])
        && validString(request.resource.data.firstName, 1, 100)
        && validTimestamp(request.resource.data.createdAt)
        && validTimestamp(request.resource.data.updatedAt)
        // Optionale Felder – Typ nur prüfen, wenn vorhanden
        && (!('nickname' in request.resource.data) || validString(request.resource.data.nickname, 0, 100))
        && (!('lastName' in request.resource.data) || validString(request.resource.data.lastName, 0, 100))
        && (!('avatarImageUrl' in request.resource.data) || validString(request.resource.data.avatarImageUrl, 1, 2000))
        && (!('birthDate' in request.resource.data) || request.resource.data.birthDate is int)
        && (!('deathDate' in request.resource.data) || request.resource.data.deathDate is int)
        && (!('calculatedAge' in request.resource.data) || request.resource.data.calculatedAge is int)
        && (!('lastMessage' in request.resource.data) || validString(request.resource.data.lastMessage, 0, 1000))
        && (!('lastMessageTime' in request.resource.data) || request.resource.data.lastMessageTime is int)
        && (!('imageUrls' in request.resource.data) || request.resource.data.imageUrls is list)
        && (!('videoUrls' in request.resource.data) || request.resource.data.videoUrls is list)
        && (!('textFileUrls' in request.resource.data) || request.resource.data.textFileUrls is list)
        && (!('audioUrls' in request.resource.data) || request.resource.data.audioUrls is list)
        && (!('writtenTexts' in request.resource.data) || request.resource.data.writtenTexts is list)
        && (!('isPublic' in request.resource.data) || request.resource.data.isPublic is bool)
        && (!('training' in request.resource.data) || request.resource.data.training is map);

      allow get, list: if isOwner(resource.data) || (resource.data.isPublic == true);
      // Allgemeines Update (ursprünglich): Owner + Konsistenz der IDs + updatedAt Pflicht
      allow update: if isOwner(resource.data)
          && request.resource.data.userId == resource.data.userId
          && request.resource.data.id == resource.data.id
          && validTimestamp(request.resource.data.updatedAt)
          && (!('training' in request.resource.data) || request.resource.data.training is map);
      allow delete: if isOwner(resource.data);
    }

    // Avatar-Medien (separate Collections pro Typ)
    match /avatars/{avatarId}/images/{mediaId} {
      allow get, list: if ownsAvatar(avatarId);
      allow create, update: if ownsAvatar(avatarId) && validMediaPricing(request.resource.data);
      allow delete: if ownsAvatar(avatarId);
    }
    match /avatars/{avatarId}/videos/{mediaId} {
      allow get, list: if ownsAvatar(avatarId);
      allow create, update: if ownsAvatar(avatarId) && validMediaPricing(request.resource.data);
      allow delete: if ownsAvatar(avatarId);
    }
    match /avatars/{avatarId}/documents/{mediaId} {
      allow get, list: if ownsAvatar(avatarId);
      allow create, update: if ownsAvatar(avatarId) && validMediaPricing(request.resource.data);
      allow delete: if ownsAvatar(avatarId);
    }
    match /avatars/{avatarId}/audios/{mediaId} {
      allow get, list: if ownsAvatar(avatarId);
      allow create, update: if ownsAvatar(avatarId) && validMediaPricing(request.resource.data);
      allow delete: if ownsAvatar(avatarId);
    }
    // Legacy-Pfad entfernt: /avatars/{avatarId}/media/** ist obsolet

    // Social Media Accounts je Avatar
    match /avatars/{avatarId}/social_accounts/{docId} {
      // Lesen: erlaubt für Owner ODER wenn Avatar öffentlich ist
      allow get, list: if ownsAvatar(avatarId) ||
        (exists(/databases/$(db)/documents/avatars/$(avatarId)) &&
         get(/databases/$(db)/documents/avatars/$(avatarId)).data.isPublic == true);
      // Schreiben: nur Owner
      allow create, update, delete: if ownsAvatar(avatarId);
    }

    // Playlists
    match /avatars/{avatarId}/playlists/{playlistId} {
      allow get, list: if ownsAvatar(avatarId);
      allow create, update, delete: if ownsAvatar(avatarId);
 
      // timelineAssets: Pool der auswählbaren Medien
      match /timelineAssets/{assetId} {
        allow get, list: if signedIn();
        // DEV-friendly: erlauben für eingeloggte Nutzer; Cloud Functions prüfen Integrität
        allow create: if signedIn();
        allow update: if signedIn();
        allow delete: if signedIn();
      }

      // timelineItems: geordnete Vorkommen in der Timeline
      match /timelineItems/{itemId} {
        allow get, list: if signedIn();
        // DEV: Erlaube Erstellen für eingeloggte Nutzer (ohne Existenz-Check),
        // damit UI-Speichern nicht an Berechtigungen scheitert. Backend-CF kann weiter aufräumen.
        allow create: if signedIn();
        // assetId darf sich nicht ändern
        allow update: if signedIn()
          && request.resource.data.assetId == resource.data.assetId;
        allow delete: if signedIn();
      }
    }

    // Playlist-Items
    match /avatars/{avatarId}/playlists/{playlistId}/items/{itemId} {
      allow get, list: if ownsAvatar(avatarId);
      allow create, update, delete: if ownsAvatar(avatarId);
    }

    // Nutzergebundene Avatare (aktuelle App-Struktur: users/{uid}/avatars/{avatarId})
    match /users/{uid}/avatars/{avatarId} {
      allow create: if signedIn()
        && uid == request.auth.uid
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.id == avatarId
        && request.resource.data.keys().hasOnly([
          'id','userId','firstName','nickname','lastName',
          'birthDate','deathDate','calculatedAge','avatarImageUrl',
          'imageUrls','videoUrls','textFileUrls','audioUrls','writtenTexts',
          'lastMessage','lastMessageTime','createdAt','updatedAt','isPublic',
          'training','role','greetingText','city','postalCode','country',
          'liveAvatar','imageTimeline','videoAudioEnabled'
        ])
        && validString(request.resource.data.firstName, 1, 100)
        && validTimestamp(request.resource.data.createdAt)
        && validTimestamp(request.resource.data.updatedAt)
        && (!('nickname' in request.resource.data) || validString(request.resource.data.nickname, 0, 100))
        && (!('lastName' in request.resource.data) || validString(request.resource.data.lastName, 0, 100))
        && (!('avatarImageUrl' in request.resource.data) || validString(request.resource.data.avatarImageUrl, 1, 2000))
        && (!('birthDate' in request.resource.data) || request.resource.data.birthDate is int)
        && (!('deathDate' in request.resource.data) || request.resource.data.deathDate is int)
        && (!('calculatedAge' in request.resource.data) || request.resource.data.calculatedAge is int)
        && (!('lastMessage' in request.resource.data) || validString(request.resource.data.lastMessage, 0, 1000))
        && (!('lastMessageTime' in request.resource.data) || request.resource.data.lastMessageTime is int)
        && (!('imageUrls' in request.resource.data) || request.resource.data.imageUrls is list)
        && (!('videoUrls' in request.resource.data) || request.resource.data.videoUrls is list)
        && (!('textFileUrls' in request.resource.data) || request.resource.data.textFileUrls is list)
        && (!('audioUrls' in request.resource.data) || request.resource.data.audioUrls is list)
        && (!('writtenTexts' in request.resource.data) || request.resource.data.writtenTexts is list)
        && (!('isPublic' in request.resource.data) || request.resource.data.isPublic is bool)
        && (!('training' in request.resource.data) || request.resource.data.training is map);

      allow get, list: if signedIn() && uid == request.auth.uid;

      allow update: if signedIn()
        && uid == request.auth.uid
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.id == resource.data.id
        && validTimestamp(request.resource.data.updatedAt);

      allow delete: if signedIn() && uid == request.auth.uid;
    }

    // Shared Moments des Nutzers je Avatar
    match /users/{uid}/avatars/{avatarId}/sharedMoments/{docId} {
      allow get, list: if signedIn() && uid == request.auth.uid;
      allow create, update, delete: if signedIn() && uid == request.auth.uid;
    }

    // Avatar-User Chat Messages (Backend-kompatibel)
    match /avatarUserChats/{chatId}/messages/{messageId} {
      // chatId format: "{userId}_{avatarId}"
      allow get, list: if signedIn() && chatId.split('_')[0] == request.auth.uid;
      allow create: if signedIn() 
        && chatId.split('_')[0] == request.auth.uid
        && request.resource.data.keys().hasOnly(['message_id', 'sender', 'content', 'timestamp', 'avatar_id', 'user_id', 'isUser', 'highlightIcon'])
        && request.resource.data.sender in ['user', 'avatar']
        && request.resource.data.content is string
        && request.resource.data.timestamp is int
        && (!('isUser' in request.resource.data) || request.resource.data.isUser is bool)
        && (!('highlightIcon' in request.resource.data) || request.resource.data.highlightIcon is string);
      allow update: if signedIn() && chatId.split('_')[0] == request.auth.uid;
      allow delete: if signedIn() && chatId.split('_')[0] == request.auth.uid;
    }

    // Hero Highlights per Avatar
    match /users/{uid}/avatars/{avatarId}/heroHighlights/{messageId} {
      allow get, list: if signedIn() && uid == request.auth.uid;
      allow create, update: if signedIn() && uid == request.auth.uid;
      allow delete: if signedIn() && uid == request.auth.uid;
    }

    // Avatar Freetexts (Struppi-System)
    match /avatars/{avatarId}/freetexts/{docId} {
      allow create: if signedIn()
        && isOwner(get(/databases/$(db)/documents/avatars/$(avatarId)).data)
        && request.resource.data.keys().hasOnly(['userId','text','createdAt'])
        && request.resource.data.userId == request.auth.uid
        && validString(request.resource.data.text, 1, 20000)
        && validTimestamp(request.resource.data.createdAt);

      allow get, list, update, delete:
        if isOwner(get(/databases/$(db)/documents/avatars/$(avatarId)).data);
    }
    
    // Legal Pages - öffentlich lesbar, nur Admins können schreiben
    match /legal_pages/{type} {
      allow read: if true; // Öffentlich lesbar
      allow write: if signedIn() && isAdmin();
    }

    // Chat Messages (Struppi-System)
    match /chats/{chatId}/messages/{messageId} {
      allow create: if signedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasOnly(['userId','text','timestamp','type'])
        && validString(request.resource.data.text, 1, 10000)
        && validTimestamp(request.resource.data.timestamp)
        && request.resource.data.type in ['user', 'avatar'];

      allow get, list: if signedIn() && 
        (resource.data.userId == request.auth.uid || 
         isOwner(get(/databases/$(db)/documents/avatars/$(chatId)).data));
    }

    // User Settings (Struppi-System)
    match /user_settings/{uid} {
      allow get, create, update, delete: if signedIn() && uid == request.auth.uid;
    }

    // Notifications (Struppi-System)
    match /notifications/{notificationId} {
      allow create: if signedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasOnly(['userId','title','message','type','read','createdAt'])
        && validString(request.resource.data.title, 1, 200)
        && validString(request.resource.data.message, 1, 1000)
        && validTimestamp(request.resource.data.createdAt)
        && request.resource.data.read is bool;

      allow get, list, update: if signedIn() && resource.data.userId == request.auth.uid;
      allow delete: if signedIn() && resource.data.userId == request.auth.uid;
    }

    // Analytics (Struppi-System)
    match /analytics/{docId} {
      allow create: if signedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasOnly(['userId','event','data','timestamp'])
        && validString(request.resource.data.event, 1, 100)
        && validTimestamp(request.resource.data.timestamp);

      allow get, list: if signedIn() && resource.data.userId == request.auth.uid;
    }
  }
}


