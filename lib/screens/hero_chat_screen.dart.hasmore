import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../screens/avatar_chat_screen.dart';

import '../models/avatar_data.dart';

/// Hero Chat Screen - Zeigt nur highlighted Nachrichten
/// Background: Hero Image
/// Filter: Icons (colored/greyscale)
class HeroChatScreen extends StatefulWidget {
  final AvatarData avatarData;
  final List<ChatMessage> messages;
  final Function(ChatMessage, String?) onIconChanged; // null = remove
  
  const HeroChatScreen({
    super.key,
    required this.avatarData,
    required this.messages,
    required this.onIconChanged,
  });

  @override
  State<HeroChatScreen> createState() => _HeroChatScreenState();
}

class _HeroChatScreenState extends State<HeroChatScreen> {
  final Set<String> _activeFilters = {}; // Icons die aktiv sind (colored)
  bool _showAllIcons = true; // Alle anzeigen oder nur gefilterte
  final List<ChatMessage> _messages = [];
  DocumentSnapshot<Map<String, dynamic>>? _lastDoc;
  bool _hasMore = true;
  bool _isLoading = false;
  bool _filterUser = true;
  bool _filterAvatar = true;

  @override
  void initState() {
    super.initState();
    // Initial: Alle Icons aktiv
    _loadHighlights();
  }

  Future<void> _loadHighlights() async {
    if (_isLoading) return;
    setState(() => _isLoading = true);
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    try {
      // Query: Alle Messages laden, dann filtern (Fallback ohne Index)
      final chatId = '${uid}_${widget.avatarData.id}';
      final snap = await FirebaseFirestore.instance
          .collection('avatarUserChats')
          .doc(chatId)
          .collection('messages')
          .orderBy('timestamp', descending: true)
          .limit(200) // Mehr laden, dann filtern
          .get();
      final loaded = <ChatMessage>[];
      final Set<String> allIcons = {};
      for (final d in snap.docs) {
        final data = d.data();
        final highlightIcon = data['highlightIcon'] as String?;
        
        // FILTER: Nur Messages mit Icon
        if (highlightIcon == null) continue;
        
        final ts = (data['timestamp'] as int?) ?? DateTime.now().millisecondsSinceEpoch;
        final sender = data['sender'] as String?;
        final content = data['content'] as String?;
        final text = content ?? data['text'] as String? ?? '';
        // FIXED: Avatar Messages explizit erkennen
        final isUser = (data['isUser'] as bool?) ?? (sender == 'user');
        
        final msg = ChatMessage(
          messageId: d.id,
          text: text,
          isUser: isUser,
          timestamp: DateTime.fromMillisecondsSinceEpoch(ts),
          highlightIcon: highlightIcon,
        );
        loaded.add(msg);
        allIcons.add(highlightIcon);
        
        // Stop bei 20 gefilterten Messages
        if (loaded.length >= 20) break;
      }
      if (!mounted) return;
      debugPrint('📥 Hero: Initial geladen: ${loaded.length}, _hasMore=${snap.docs.length == 20}');
      setState(() {
        _messages
          ..clear()
          ..addAll(loaded.reversed); // älteste zuerst
        _activeFilters
          ..clear()
          ..addAll(allIcons);
        _lastDoc = snap.docs.isNotEmpty ? snap.docs.last : null;
        _hasMore = snap.docs.length == 20; // Link zeigen, wenn volle 20 geladen wurden
        _isLoading = false;
      });
    } catch (_) {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<void> _loadMore() async {
    if (_isLoading || !_hasMore) return;
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null || _lastDoc == null) return;
    
    debugPrint('📥 Hero: _loadMore start...');
    setState(() => _isLoading = true);
    
    try {
      final chatId = '${uid}_${widget.avatarData.id}';
      final snap = await FirebaseFirestore.instance
          .collection('avatarUserChats')
          .doc(chatId)
          .collection('messages')
          .orderBy('timestamp', descending: true)
          .startAfterDocument(_lastDoc!)
          .limit(200)
          .get();
      
      debugPrint('📥 Hero: Gefunden ${snap.docs.length} weitere Messages');
      
      final more = <ChatMessage>[];
      for (final d in snap.docs) {
        final data = d.data();
        final highlightIcon = data['highlightIcon'] as String?;
        
        // FILTER: Nur Messages mit Icon
        if (highlightIcon == null) continue;
        
        final ts = (data['timestamp'] as int?) ?? DateTime.now().millisecondsSinceEpoch;
        final sender = data['sender'] as String?;
        final content = data['content'] as String?;
        final text = content ?? data['text'] as String? ?? '';
        // FIXED: Avatar Messages explizit erkennen
        final isUser = (data['isUser'] as bool?) ?? (sender == 'user');
        
        more.add(ChatMessage(
          messageId: d.id,
          text: text,
          isUser: isUser,
          timestamp: DateTime.fromMillisecondsSinceEpoch(ts),
          highlightIcon: highlightIcon,
        ));
        
        // Stop bei 20 gefilterten Messages
        if (more.length >= 20) break;
      }
      if (!mounted) return;
      setState(() {
        _messages.insertAll(0, more.reversed); // ältere oben ergänzen
        _lastDoc = snap.docs.isNotEmpty ? snap.docs.last : _lastDoc;
        _hasMore = snap.docs.length == 20; // Weiter laden, wenn volle 20 geladen wurden
        _isLoading = false;
      });
      
      debugPrint('✅ Hero: ${more.length} weitere geladen. Total: ${_messages.length}');
    } catch (e) {
      debugPrint('❌ Hero: _loadMore fehlgeschlagen: $e');
      if (mounted) setState(() => _isLoading = false);
    }
  }

  List<ChatMessage> get _filteredMessages {
    Iterable<ChatMessage> it = _messages.where((m) => m.isHighlighted);
    if (!_showAllIcons) {
      it = it.where((m) => m.highlightIcon != null && _activeFilters.contains(m.highlightIcon!));
    }
    it = it.where((m) => (_filterUser && m.isUser) || (_filterAvatar && !m.isUser));
    return it.toList();
  }

  List<String> get _allUsedIcons {
    final Set<String> icons = {};
    for (final msg in _messages) {
      if (msg.highlightIcon != null) {
        icons.add(msg.highlightIcon!);
      }
    }
    return icons.toList();
  }

  @override
  Widget build(BuildContext context) {
    final heroImageUrl = widget.avatarData.avatarImageUrl;
    
    return Scaffold(
      body: GestureDetector(
        onHorizontalDragEnd: (details) {
          // Wischen nach links = zurück
          if (details.primaryVelocity != null && details.primaryVelocity! < -500) {
            Navigator.pop(context);
          }
        },
        child: Stack(
          children: [
            // Background: Hero Image
            if (heroImageUrl != null && heroImageUrl.isNotEmpty)
              Positioned.fill(
                child: Image.network(
                  heroImageUrl,
                  fit: BoxFit.cover,
                  errorBuilder: (_, __, ___) => Container(color: Colors.black),
                ),
              ),
            
            // Dark Overlay für bessere Lesbarkeit
            Positioned.fill(
              child: Container(
                color: Colors.black.withValues(alpha: 0.6),
              ),
            ),

            // Content
            SafeArea(
              child: Column(
                children: [
                  // Header mit Icon-Filtern
                  _buildHeader(),
                  
                  // Load more link
                  if (_hasMore)
                    GestureDetector(
                      onTap: _isLoading ? null : _loadMore,
                      child: Padding(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        child: Text(
                          _isLoading ? 'Lade ältere Highlights…' : 'Ältere Highlights anzeigen',
                          style: const TextStyle(
                            color: Colors.white70,
                            fontSize: 12,
                            decoration: TextDecoration.underline,
                          ),
                        ),
                      ),
                    ),

                  // Messages
                  Expanded(
                    child: _filteredMessages.isEmpty
                        ? _buildEmptyState()
                        : _buildMessageList(),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildHeader() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.black.withValues(alpha: 0.7),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.3),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        children: [
          // Title + Close
          Row(
            children: [
              GestureDetector(
                onTap: () => Navigator.pop(context),
                child: Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.white.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: const Icon(Icons.arrow_back, color: Colors.white),
                ),
              ),
              const SizedBox(width: 12),
              const Expanded(
                child: Text(
                  'Hero Chat',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              Text(
                '${_filteredMessages.length} Highlights',
                style: TextStyle(
                  color: Colors.white.withValues(alpha: 0.7),
                  fontSize: 14,
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 16),
          
          // Icon Filters
          _buildIconFilters(),

          const SizedBox(height: 8),

          // Sender-Filter (User / Avatar)
          Row(
            children: [
              _buildSenderToggle(
                active: _filterUser,
                label: 'User',
                imageUrl: FirebaseAuth.instance.currentUser?.photoURL,
                fallbackIcon: Icons.person,
                onTap: () => setState(() => _filterUser = !_filterUser),
              ),
              const SizedBox(width: 8),
              _buildSenderToggle(
                active: _filterAvatar,
                label: 'Avatar',
                imageUrl: widget.avatarData.avatarImageUrl,
                fallbackIcon: Icons.smart_toy_outlined,
                onTap: () => setState(() => _filterAvatar = !_filterAvatar),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildSenderToggle({
    required bool active,
    required String label,
    required String? imageUrl,
    required IconData fallbackIcon,
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
        decoration: BoxDecoration(
          color: active ? Colors.white.withValues(alpha: 0.2) : Colors.white.withValues(alpha: 0.05),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: active ? Colors.white.withValues(alpha: 0.6) : Colors.white.withValues(alpha: 0.2),
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircleAvatar(
              radius: 10,
              backgroundColor: Colors.white.withValues(alpha: 0.1),
              backgroundImage: (imageUrl != null && imageUrl.isNotEmpty) ? NetworkImage(imageUrl) : null,
              child: (imageUrl == null || imageUrl.isEmpty)
                  ? Icon(fallbackIcon, size: 14, color: Colors.white70)
                  : null,
            ),
            const SizedBox(width: 6),
            Text(
              label,
              style: const TextStyle(color: Colors.white, fontSize: 12),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildIconFilters() {
    final usedIcons = _allUsedIcons;
    
    if (usedIcons.isEmpty) {
      return const SizedBox.shrink();
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // All Toggle
        Row(
          children: [
            Text(
              'Filter:',
              style: TextStyle(
                color: Colors.white.withValues(alpha: 0.7),
                fontSize: 12,
              ),
            ),
            const SizedBox(width: 8),
            GestureDetector(
              onTap: () {
                setState(() {
                  _showAllIcons = !_showAllIcons;
                });
              },
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                decoration: BoxDecoration(
                  color: _showAllIcons
                      ? Colors.white.withValues(alpha: 0.3)
                      : Colors.white.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(
                    color: _showAllIcons
                        ? Colors.white.withValues(alpha: 0.8)
                        : Colors.white.withValues(alpha: 0.3),
                  ),
                ),
                child: Text(
                  _showAllIcons ? 'Alle' : 'Gefiltert',
                  style: const TextStyle(color: Colors.white, fontSize: 12),
                ),
              ),
            ),
          ],
        ),
        
        const SizedBox(height: 8),
        
        // Icon Toggles
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: usedIcons.map((icon) => _buildIconToggle(icon)).toList(),
        ),
      ],
    );
  }

  Widget _buildIconToggle(String icon) {
    final isActive = _activeFilters.contains(icon);
    final count = _messages.where((m) => m.highlightIcon == icon).length;

    return GestureDetector(
      onTap: () {
        setState(() {
          if (isActive) {
            _activeFilters.remove(icon);
            _showAllIcons = false;
          } else {
            _activeFilters.add(icon);
          }
        });
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
        decoration: BoxDecoration(
          color: isActive
              ? Colors.white.withValues(alpha: 0.2)
              : Colors.white.withValues(alpha: 0.05),
          borderRadius: BorderRadius.circular(10),
          border: Border.all(
            color: isActive
                ? Colors.white.withValues(alpha: 0.5)
                : Colors.white.withValues(alpha: 0.2),
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Icon (colored wenn aktiv, greyscale wenn nicht)
            Opacity(
              opacity: isActive ? 1.0 : 0.3,
              child: Text(
                icon,
                style: TextStyle(
                  fontSize: 18,
                  color: isActive ? null : Colors.grey,
                ),
              ),
            ),
            const SizedBox(width: 4),
            Text(
              '$count',
              style: TextStyle(
                color: Colors.white.withValues(alpha: isActive ? 0.9 : 0.4),
                fontSize: 12,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.bookmark_border,
            size: 80,
            color: Colors.white.withValues(alpha: 0.3),
          ),
          const SizedBox(height: 16),
          Text(
            'Keine Highlights',
            style: TextStyle(
              color: Colors.white.withValues(alpha: 0.7),
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Markiere Chat-Nachrichten mit Icons',
            style: TextStyle(
              color: Colors.white.withValues(alpha: 0.5),
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMessageList() {
    final items = <Widget>[];
    DateTime? lastDate;
    for (final m in _filteredMessages) {
      final day = DateTime(m.timestamp.year, m.timestamp.month, m.timestamp.day);
      if (lastDate == null || day.isAfter(lastDate)) {
        items.add(_buildDateSeparator(day));
        lastDate = day;
      }
      items.add(_buildMessageCard(m));
    }
    return ListView(
      padding: const EdgeInsets.all(16),
      children: items,
    );
  }

  Widget _buildDateSeparator(DateTime day) {
    final label = _formatDay(day);
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
            decoration: BoxDecoration(
              color: Colors.white.withValues(alpha: 0.15),
              borderRadius: BorderRadius.circular(12),
            ),
            child: Text(
              label,
              style: const TextStyle(color: Colors.white70, fontSize: 12),
            ),
          ),
        ],
      ),
    );
  }

  String _formatDay(DateTime d) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = today.subtract(const Duration(days: 1));
    final day = DateTime(d.year, d.month, d.day);
    if (day == today) return 'Heute';
    if (day == yesterday) return 'Gestern';
    return '${d.day.toString().padLeft(2, '0')}.${d.month.toString().padLeft(2, '0')}.${d.year}';
  }

  Widget _buildMessageCard(ChatMessage message) {
    // WhatsApp-Style Bubble (gleiche Größe wie Chat)
    final bubble = Container(
      constraints: BoxConstraints(
        maxWidth: MediaQuery.of(context).size.width * 0.75,
      ),
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
      decoration: BoxDecoration(
        gradient: message.isUser
            ? const LinearGradient(
                colors: [
                  Color(0xFFFFD5F4), // White + 20% Magenta
                  Color(0xFFE8F0FE), // White + 20% LightBlue
                ],
              )
            : null,
        color: message.isUser ? null : const Color(0xFFF5F5F5), // Avatar: lightest grey
        borderRadius: message.isUser
            ? const BorderRadius.only(
                topLeft: Radius.circular(8),
                topRight: Radius.circular(8),
                bottomLeft: Radius.circular(8),
                bottomRight: Radius.circular(2),
              )
            : const BorderRadius.only(
                topLeft: Radius.circular(8),
                topRight: Radius.circular(8),
                bottomLeft: Radius.circular(2),
                bottomRight: Radius.circular(8),
              ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.2),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          // Icon + Text
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (message.highlightIcon != null)
                Padding(
                  padding: const EdgeInsets.only(right: 6),
                  child: Text(message.highlightIcon!, style: const TextStyle(fontSize: 18)),
                ),
              Expanded(
                child: Text(
                  message.text,
                  style: const TextStyle(
                    color: Color(0xFF2E2E2E), // dark grey (wie in Chat)
                    fontSize: 13,
                    height: 1.35,
                  ),
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 4),
          
          // Bottom Row: Nur Zeit (rechts)
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              // Timestamp
              Text(
                '${message.timestamp.hour.toString().padLeft(2, '0')}:${message.timestamp.minute.toString().padLeft(2, '0')}',
                style: TextStyle(
                  color: Colors.black.withValues(alpha: 0.4),
                  fontSize: 10,
                ),
              ),
            ],
          ),
        ],
      ),
    );

    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: message.isUser
            ? [
                const Spacer(),
                Flexible(child: bubble),
              ]
            : [
                Flexible(child: bubble),
                const Spacer(),
              ],
      ),
    );
  }

}

